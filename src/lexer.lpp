%{ /* -*- C++ -*- */
#include <cstdlib>
#include <string>

// 因为 Flex 会用到 Bison 中关于 token 的定义
// 所以需要 include Bison 生成的头文件
#include "parser.tab.hh"
#include "driver.h"
%}

%option noyywrap nounput noinput batch debug

/* Lexing a token immediately after consuming some whitespace. */
%s AFTER_WHITESPACE
/*
 * Lexing a token immediately after consuming an operand-ending token:
 * a closing bracket, IDENTIFIER, or literal.
 */
%s AFTER_OPERAND

VOID                 "void"

BOOL                 "bool"

SIZE                 "size"

I8                   "i8"
I16                  "i16"
I32                  "i32"
I64                  "i64"
I128                 "i128"

U8                   "u8"
U16                  "u16"
U32                  "u32"
U64                  "u64"
U128                 "u128"

F16                  "f16"
F32                  "f32"
F64                  "f64"
F128                 "f128"

D32                  "d32"
D64                  "d64"

C8                   "c8"
C16                  "c16"
C32                  "c32"

CONST                "const"
VOLATILE             "volatile"

MAIN                 "main"
LET                  "let"
CLASS                "class"
IF                   "if"
ELSE                 "else"

LOOP                 "loop"
BREAK                "break"
CONTINUE             "continue"
SEMICOLON            ";"
ASSIGN               ":="
BITWISE_NOT          "~"
B_AND                "&"
B_XOR                "^"
B_OR                 "|"
LEFT_CURLY_BRACE     "{"
LEFT_PARENTHESIS     "("
LEFT_SQUARE_BRACKET  "["
PLUS                 "+"
MINUS                "-"
PERCENT              "%"
SLASH                "/"
DOT                  "."
RIGHT_CURLY_BRACE    "}"
RIGHT_PARENTHESIS    ")"
RIGHT_SQUARE_BRACKET "]"

THREE_WAY_COMPARISON "<=>"
LESS                 "<"
LESS_EQUAL           "<="
GREATER              ">"
GREATER_EQUAL        ">="
EQUAL                "=="
NOT_EQUAL            "!="

LOGICAL_NOT          "!"
AND                  "&&"
OR                   "||"

COMMA                ","

/* 空白符和注释 */
horizontal_whitespace [ \t\r]
whitespace            [ \t\r\n]

one_line_comment      \/\/[^\n]*\n

/* 标识符 */
IDENTIFIER    [a-zA-Z_][a-zA-Z0-9_]*
operand_start         [(A-Za-z0-9_\"]



BINARY_DIGIT      [01]
ZERO              0
OCTAL_DIGIT       [0-7]
NONZERO_DIGIT     [1-9]
DIGIT             [0-9]
HEXADECIMAL_DIGIT [0-9a-fA-F]
/* 整数字面量 */

LOWERCASE_BINARY_PREFIX 0b
UPPERCASE_BINARY_PREFIX 0B
LOWERCASE_HEXADECIMAL_PREFIX 0x
UPPERCASE_HEXADECIMAL_PREFIX 0X
%{
  // Code run each time a pattern is matched.
  # define YY_USER_ACTION  loc.columns (yyleng);
%}
%%
%{
  // A handy shortcut to the location held by the driver.
  pache::location loc;
  // Code run each time yylex is called.
  loc.step ();
%}
{MAIN}          { return pache::parser::make_MAIN(loc); }
{LET}           { return pache::parser::make_LET(loc); }
{BITWISE_NOT}   { return pache::parser::make_BITWISE_NOT(loc); }
{B_AND}         { return pache::parser::make_B_AND(loc); }
{B_XOR}         { return pache::parser::make_B_XOR(loc); }
{B_OR}         { return pache::parser::make_B_OR(loc); }
{IF}            { return pache::parser::make_IF(loc); }
{ELSE}          { return pache::parser::make_ELSE(loc); }

{ASSIGN}        { return pache::parser::make_ASSIGN(loc); }
{one_line_comment}   { /* 忽略, 不做任何操作 */ }
{horizontal_whitespace}+ {
  // Make the span empty by setting start to end.
  //context.current_token_position.step();
  BEGIN(AFTER_WHITESPACE);
}

{VOID}          { return pache::parser::make_VOID(loc); }

{BOOL}          { return pache::parser::make_BOOL(loc); }

{SIZE}          { return pache::parser::make_SIZE(loc); }

{I8}            { return pache::parser::make_I8(loc); }
{I16}           { return pache::parser::make_I16(loc); }
{I32}           { return pache::parser::make_I32(loc); }
{I64}           { return pache::parser::make_I64(loc); }
{I128}          { return pache::parser::make_I128(loc); }

{U8}            { return pache::parser::make_U8(loc); }
{U16}           { return pache::parser::make_U16(loc); }
{U32}           { return pache::parser::make_U32(loc); }
{U64}           { return pache::parser::make_U64(loc); }
{U128}          { return pache::parser::make_U128(loc); }

{F16}           { return pache::parser::make_F16(loc); }
{F32}           { return pache::parser::make_F32(loc); }
{F64}           { return pache::parser::make_F64(loc); }
{F128}          { return pache::parser::make_F128(loc); }

{D32}           { return pache::parser::make_D32(loc); }
{D64}           { return pache::parser::make_D64(loc); }

{C8}            { return pache::parser::make_C8(loc); }
{C16}           { return pache::parser::make_C16(loc); }
{C32}           { return pache::parser::make_C32(loc); }

{CONST}         { return pache::parser::make_CONST(loc);}
{VOLATILE}         { return pache::parser::make_VOLATILE(loc);}
"return"        { return pache::parser::make_RETURN(loc); }
"func"          { return pache::parser::make_FUNC(loc); }
{CLASS}                 { return pache::parser::make_CLASS(loc); }


{LEFT_CURLY_BRACE}      { return pache::parser::make_LEFT_CURLY_BRACE(loc); }
{LEFT_PARENTHESIS}      { return pache::parser::make_LEFT_PARENTHESIS(loc); }
{LEFT_SQUARE_BRACKET}   { return pache::parser::make_LEFT_SQUARE_BRACKET(loc); }
{PLUS}                  { return pache::parser::make_PLUS(loc); }
{MINUS}                 { return pache::parser::make_MINUS(loc); }
{PERCENT}               { return pache::parser::make_PERCENT(loc); }
{SLASH}                 { return pache::parser::make_SLASH(loc); }
{DOT}                { return pache::parser::make_DOT(loc); }

{THREE_WAY_COMPARISON}  { return pache::parser::make_THREE_WAY_COMPARISON(loc); }
{LESS}                  { return pache::parser::make_LESS(loc); }
{LESS_EQUAL}            { return pache::parser::make_LESS_EQUAL(loc); }
{GREATER}               { return pache::parser::make_GREATER(loc); }
{GREATER_EQUAL}         { return pache::parser::make_GREATER_EQUAL(loc); }
{EQUAL}                 { return pache::parser::make_EQUAL(loc); }
{NOT_EQUAL}             { return pache::parser::make_NOT_EQUAL(loc); }

{LOGICAL_NOT}           { return pache::parser::make_LOGICAL_NOT(loc); }
{AND}                   { return pache::parser::make_AND(loc); }
{OR}                    { return pache::parser::make_OR(loc); }

{LOOP}                  { return pache::parser::make_LOOP(loc); }
{BREAK}                 { return pache::parser::make_BREAK(loc); }
{CONTINUE}              { return pache::parser::make_CONTINUE(loc); }



{COMMA}                 { return pache::parser::make_COMMA(loc); }
{SEMICOLON}           { return pache::parser::make_SEMICOLON(loc); }
{IDENTIFIER}   { return pache::parser::make_IDENTIFIER(yytext, loc);}

{BINARY_DIGIT} {return pache::parser::make_BINARY_DIGIT(yytext, loc); }
{ZERO} {return pache::parser::make_ZERO(loc); }
{OCTAL_DIGIT} {return pache::parser::make_OCTAL_DIGIT(yytext, loc); }
{NONZERO_DIGIT} {return pache::parser::make_NONZERO_DIGIT(yytext, loc); }
{DIGIT} {return pache::parser::make_DIGIT(yytext, loc); }
{HEXADECIMAL_DIGIT} {return pache::parser::make_HEXADECIMAL_DIGIT(yytext, loc); }

{LOWERCASE_BINARY_PREFIX} { return pache::parser::make_LOWERCASE_BINARY_PREFIX(loc); }
{UPPERCASE_BINARY_PREFIX} { return pache::parser::make_UPPERCASE_BINARY_PREFIX(loc); }
{LOWERCASE_HEXADECIMAL_PREFIX} { return pache::parser::make_LOWERCASE_HEXADECIMAL_PREFIX(loc); }
{UPPERCASE_HEXADECIMAL_PREFIX} { return pache::parser::make_UPPERCASE_HEXADECIMAL_PREFIX(loc); }

\n+    {   // Advance end by yyleng lines, resetting the column to zero.
  //context.current_token_position.lines(yyleng);
  // Make the span empty by setting start to end.
  //context.current_token_position.step();
  BEGIN(AFTER_WHITESPACE);
   }
{RIGHT_PARENTHESIS} {
  BEGIN(AFTER_OPERAND);
  return pache::parser::make_RIGHT_PARENTHESIS(loc);
}
{RIGHT_CURLY_BRACE} {
  BEGIN(AFTER_OPERAND);
  return pache::parser::make_RIGHT_CURLY_BRACE(loc);
}
{RIGHT_SQUARE_BRACKET} {
  BEGIN(AFTER_OPERAND);
  return pache::parser::make_RIGHT_SQUARE_BRACKET(loc);
}

 /* `*` operator case 1: */
<AFTER_WHITESPACE>"*"{whitespace}+ {
  BEGIN(AFTER_WHITESPACE);
  return pache::parser::make_BINARY_STAR(loc);
}
 /* `*` operator case 2: */
{horizontal_whitespace}"*"{horizontal_whitespace} { return pache::parser::make_BINARY_STAR(loc); }
 /* `*` operator case 3: */
<AFTER_WHITESPACE>"*" { return pache::parser::make_PREFIX_STAR(loc); }
 /* `*` operator case 4: */
<INITIAL,AFTER_OPERAND>"*"{whitespace}+ {
  BEGIN(AFTER_WHITESPACE);
  return pache::parser::make_POSTFIX_STAR(loc);
}
 /* `*` operator case 5: */
<INITIAL,AFTER_OPERAND>"*" { return pache::parser::make_UNARY_STAR(loc); }

<<EOF>>  return pache::parser::make_EOF (loc);
%%

void
pache::driver::scan_begin ()
{
  yy_flex_debug = trace_scanning;
  if (file_name.empty () || file_name == "-")
    yyin = stdin;
  else if (!(yyin = fopen (file_name.c_str (), "r")))
    {
      std::cerr << "cannot open " << file_name << ": " << strerror (errno) << '\n';
      exit (EXIT_FAILURE);
    }
}

void
pache::driver::scan_end ()
{
  fclose (yyin);
}

## 整数字面量

---

允许在表达式中直接使用整数类型的值。

### 语法

整数字面量拥有以下形式

|     |     |
| --- | --- |
| 十进制字面量 整数类型后缀(可选) | (1) |
| 八进制字面量 整数类型后缀(可选) | (2) |
| 十六进制字面量 整数类型后缀(可选) | (3) |
| 二进制字面量 整数类型后缀(可选) | (4) |

其中

- 十进制字面量 是一个非零十进制位（`1`、`2`、`3`、`4`、`5`、`6`、`7`、`8`、`9`）后随零或多个十进制位（`0`、`1`、`2`、`3`、`4`、`5`、`6`、`7`、`8`、`9`）
- 八进制字面量 是数位零（`0`）后随零或多个八进制位（`0`、`1`、`2`、`3`、`4`、`5`、`6`、`7`）
- 十六进制字面量 是字符序列 `0x` 或字符序列 `0X` 后随一或多个十六进制数位（`0`、`1`、`2`、`3`、`4`、`5`、`6`、`7`、`8`、`9`、`a`、`A`、`b`、`B`、`c`、`C`、`d`、`D`、`e`、`E`、`f`、`F`）
- 二进制字面量 是字符序列 `0b` 或字符序列 `0B` 后随一或多个二进制位（`0`、`1`）
- 若提供 整数类型后缀，则可含有下列之一：
  - *默认为`i32`*
  - `i` `i8` `i16` `i32` `i64` `i128` *有符号整数类型 `i`默认为`i32`*
  - `u` `u8` `u16` `u32` `u64` `u128` *无符号整数类型 `u`默认为`u32`*
  - `z` *有符号指针类型*
  - `s` *无符号指针类型*

数位间可插入作为分隔符的可选的单引号（`'`）。编译器会忽略它们。

整数字面量（与任何字面量相同）是[初等表达式](/language/expressions#.E5.88.9D.E7.AD.89.E8.A1.A8.E8.BE.BE.E5.BC.8F "language/expressions")。

### 解释

1. 十进制整数字面量（以 10 为底）

2. 八进制整数字面量（以 8 为底）

3. 十六进制整数字面量（以 16 为底，字母 'a' 到 'f' 表示（十进制）值 10 到 15）

4. 二进制整数字面量（以 2 为底）

整数字面量的首位为最高位。

例如，下列变量被初始化到相同值：

```rust
i32 d = 42;
i32 o = 052;
i32 x = 0x2a;
i32 X = 0X2A;
i32 b = 0b101010;
```

例如，下列变量也被初始化为相同值：

```rust
u64 l1 = 18446744073709550592;
u64 l2 = 18'446'744'073'709'550'592;
u64 l3 = 1844'6744'0737'0955'0592u64;
u64 l4 = 184467'440737'0'95505'92u64;
```

### 字面量的类型

整数字面量的类型取决于 *整数类型后缀* 及默认规则。

若整数字面量的值过大，而无法符合任何后缀/底组合所允许的类型则程序非良构。

### 注解

整数字面量中的字母是无关大小写的：`0xDeAdBaBeU` 与 `0XdeadBABEu` 表示同一数值。

没有负整数字面量。如 \-1 这样的表达式对字面量所表示的值运用[一元减运算符](/language/operator_arithmetic "language/operator arithmetic")，这可能涉及隐式转换。

由于[最大吞噬](/language/translation_phases#.E6.9C.80.E5.A4.A7.E5.90.9E.E5.99.AC "language/translation phases")规则，以 `e` 和 `E` 结束的十六进制整数字面量在后随运算符 `+` 或 `-` 时，源码中必须以空白符或括号将它们与运算符分隔：

```cpp
auto x = 0xE+2.0;   // 错误
auto y = 0xa+2.0;   // OK
auto z = 0xE +2.0;  // OK
auto q = (0xE)+2.0; // OK
```

否则，将构成一个非法的预处理数字记号，并导致进一步的分析失败。

### 示例

```cpp
#include <iostream>
#include <type_traits>
 
func main() void {
std::cout << 123    << '\n'
          << 0123   << '\n'
          << 0x123  << '\n'
          << 0b10   << '\n'
          << 12345678901234567890u64 << '\n'
          << 12345678901234567890u   << '\n'; // 类型是 u64
                                              // 即使无 u64 后缀
 
//   std::cout << -9223372036854775808 << '\n'; // 错误：值 9223372036854775808
                // 不吻合 i64，这是无后缀整数字面量允许的最大类型
                //   std::cout << -9223372036854775808u << '\n'; // 应用于无符号值的一元减
                // 从 2^64 减去该值，给出 9223372036854775808
     std::cout << -9223372036854775807 - 1 << '\n'; // 计算值 -9223372036854775808
                                                    // 的正确方式
 
     static_assert(std::is_same_v<decltype(0s), std::size_t>);
     static_assert(std::is_same_v<decltype(0z), std::make_signed_t<std::size_t>>);
}
```

输出：

```
123
83
291
2
12345678901234567890
12345678901234567890
-9223372036854775808
```

### 参阅
